{
  "README.html": {
    "href": "README.html",
    "title": "Documentation | BurstTriangulator",
    "keywords": "Documentation Place .dll files for Unity, Burst, Collections, etc. in the dlls/ folder. Navigate to the Documentation~/ folder. Build documentation using docfx. Optionally, if make is available, run make serve to build and open documentation in the browser. Note unity-xrefmap.yml contains cross-references between packages. This file is filled manually since there are only a few references to external definitions in the public API."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.-ctor.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.-ctor.html",
    "title": "Constructor Triangulator | BurstTriangulator",
    "keywords": "Constructor Triangulator Triangulator(int, Allocator) Declaration public Triangulator(int capacity, Allocator allocator) Parameters Type Name Description int capacity Allocator allocator Triangulator(Allocator) Declaration public Triangulator(Allocator allocator) Parameters Type Name Description Allocator allocator"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Dispose.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Dispose.html",
    "title": "Method Dispose | BurstTriangulator",
    "keywords": "Method Dispose Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable.Dispose()"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Input.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Input.html",
    "title": "Property Input | BurstTriangulator",
    "keywords": "Property Input Input Declaration public Triangulator.InputData Input { get; set; } Property Value Type Description Triangulator.InputData"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.InputData.ConstraintEdges.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.InputData.ConstraintEdges.html",
    "title": "Property ConstraintEdges | BurstTriangulator",
    "keywords": "Property ConstraintEdges ConstraintEdges Declaration public NativeArray<int> ConstraintEdges { get; set; } Property Value Type Description NativeArray<int>"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.InputData.HoleSeeds.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.InputData.HoleSeeds.html",
    "title": "Property HoleSeeds | BurstTriangulator",
    "keywords": "Property HoleSeeds HoleSeeds Declaration public NativeArray<float2> HoleSeeds { get; set; } Property Value Type Description NativeArray<float2>"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.InputData.Positions.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.InputData.Positions.html",
    "title": "Property Positions | BurstTriangulator",
    "keywords": "Property Positions Positions Declaration public NativeArray<float2> Positions { get; set; } Property Value Type Description NativeArray<float2>"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.InputData.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.InputData.html",
    "title": "Class Triangulator.InputData | BurstTriangulator",
    "keywords": "Class Triangulator.InputData Inheritance object Triangulator.InputData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public class Triangulator.InputData Properties Name Description ConstraintEdges HoleSeeds Positions"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Output.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Output.html",
    "title": "Property Output | BurstTriangulator",
    "keywords": "Property Output Output Declaration public Triangulator.OutputData Output { get; } Property Value Type Description Triangulator.OutputData"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.OutputData.Positions.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.OutputData.Positions.html",
    "title": "Field Positions | BurstTriangulator",
    "keywords": "Field Positions Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax [NativeDisableContainerSafetyRestriction] public NativeList<float2> Positions Returns Type Description NativeList<float2>"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.OutputData.Status.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.OutputData.Status.html",
    "title": "Field Status | BurstTriangulator",
    "keywords": "Field Status Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public NativeReference<Triangulator.Status> Status Returns Type Description NativeReference<Triangulator.Status>"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.OutputData.Triangles.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.OutputData.Triangles.html",
    "title": "Field Triangles | BurstTriangulator",
    "keywords": "Field Triangles Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public NativeList<int> Triangles Returns Type Description NativeList<int>"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.OutputData.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.OutputData.html",
    "title": "Struct Triangulator.OutputData | BurstTriangulator",
    "keywords": "Struct Triangulator.OutputData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public struct Triangulator.OutputData Fields Name Description Positions Status Triangles"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Preprocessor.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Preprocessor.html",
    "title": "Enum Triangulator.Preprocessor | BurstTriangulator",
    "keywords": "Enum Triangulator.Preprocessor Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public enum Triangulator.Preprocessor Fields Name Description COM Transforms Input to local coordinate system using center of mass. None PCA Transforms Input using coordinate system obtained from principal component analysis."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.RefinementThresholds.Angle.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.RefinementThresholds.Angle.html",
    "title": "Property Angle | BurstTriangulator",
    "keywords": "Property Angle Angle Specifies the refinement angle constraint for triangles in the resulting mesh. Ensures that no triangle in the mesh has an angle smaller than the specified value. Declaration public float Angle { get; set; } Property Value Type Description float Remarks Expressed in radians."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.RefinementThresholds.Area.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.RefinementThresholds.Area.html",
    "title": "Property Area | BurstTriangulator",
    "keywords": "Property Area Area Specifies the maximum area constraint for triangles in the resulting mesh refinement. Ensures that no triangle in the mesh has an area larger than the specified value. Declaration public float Area { get; set; } Property Value Type Description float"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.RefinementThresholds.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.RefinementThresholds.html",
    "title": "Class Triangulator.RefinementThresholds | BurstTriangulator",
    "keywords": "Class Triangulator.RefinementThresholds Inheritance object Triangulator.RefinementThresholds Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax [Serializable] public class Triangulator.RefinementThresholds Properties Name Description Angle Specifies the refinement angle constraint for triangles in the resulting mesh. Ensures that no triangle in the mesh has an angle smaller than the specified value. Area Specifies the maximum area constraint for triangles in the resulting mesh refinement. Ensures that no triangle in the mesh has an area larger than the specified value."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Run.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Run.html",
    "title": "Method Run | BurstTriangulator",
    "keywords": "Method Run Run() Declaration public void Run()"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Schedule.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Schedule.html",
    "title": "Method Schedule | BurstTriangulator",
    "keywords": "Method Schedule Schedule(JobHandle) Declaration public JobHandle Schedule(JobHandle dependencies = default) Parameters Type Name Description JobHandle dependencies Returns Type Description JobHandle"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Settings.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Settings.html",
    "title": "Property Settings | BurstTriangulator",
    "keywords": "Property Settings Settings Declaration public Triangulator.TriangulationSettings Settings { get; } Property Value Type Description Triangulator.TriangulationSettings"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.Status.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.Status.html",
    "title": "Enum Triangulator.Status | BurstTriangulator",
    "keywords": "Enum Triangulator.Status Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public enum Triangulator.Status Fields Name Description ERR State may suggest that some error occurs during triangulation. See console for more details. OK State corresponds to triangulation completed successfully."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.BatchCount.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.BatchCount.html",
    "title": "Property BatchCount | BurstTriangulator",
    "keywords": "Property BatchCount BatchCount Batch count used in parallel jobs. Declaration [Obsolete(\"This property is no longer used. Setting it has no effect.\")] public int BatchCount { get; set; } Property Value Type Description int"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.ConcentricShellsParameter.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.ConcentricShellsParameter.html",
    "title": "Property ConcentricShellsParameter | BurstTriangulator",
    "keywords": "Property ConcentricShellsParameter ConcentricShellsParameter Constant used in concentric shells segment splitting. Modify this only if you know what you are doing! Declaration public float ConcentricShellsParameter { get; set; } Property Value Type Description float"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.ConstrainEdges.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.ConstrainEdges.html",
    "title": "Property ConstrainEdges | BurstTriangulator",
    "keywords": "Property ConstrainEdges ConstrainEdges If true constrains edges defined in Input using Sloan's algorithm. Declaration [Obsolete(\"To enable constraint edges, pass the corresponding array into Input.ConstraintEdges. Setting this property is unnecessary.\", true)] public bool ConstrainEdges { get; set; } Property Value Type Description bool"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.MaximumArea.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.MaximumArea.html",
    "title": "Property MaximumArea | BurstTriangulator",
    "keywords": "Property MaximumArea MaximumArea Specifies the maximum area constraint for triangles in the resulting mesh refinement. Ensures that no triangle in the mesh has an area larger than the specified value. Declaration [Obsolete] public float MaximumArea { get; set; } Property Value Type Description float Remarks Obsolete: use Area instead."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.MinimumAngle.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.MinimumAngle.html",
    "title": "Property MinimumAngle | BurstTriangulator",
    "keywords": "Property MinimumAngle MinimumAngle Specifies the refinement angle constraint for triangles in the resulting mesh. Ensures that no triangle in the mesh has an angle smaller than the specified value. Expressed in radians. Declaration [Obsolete] public float MinimumAngle { get; set; } Property Value Type Description float Remarks Obsolete: use Angle instead."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.MinimumArea.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.MinimumArea.html",
    "title": "Property MinimumArea | BurstTriangulator",
    "keywords": "Property MinimumArea MinimumArea Specifies the maximum area constraint for triangles in the resulting mesh refinement. Ensures that no triangle in the mesh has an area larger than the specified value. Declaration [Obsolete] public float MinimumArea { get; set; } Property Value Type Description float Remarks Obsolete: use Area instead."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.Preprocessor.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.Preprocessor.html",
    "title": "Property Preprocessor | BurstTriangulator",
    "keywords": "Property Preprocessor Preprocessor Preprocessing algorithm for the input data. Default is None. Declaration public Triangulator.Preprocessor Preprocessor { get; set; } Property Value Type Description Triangulator.Preprocessor"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.RefineMesh.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.RefineMesh.html",
    "title": "Property RefineMesh | BurstTriangulator",
    "keywords": "Property RefineMesh RefineMesh If true refines mesh using Ruppert's algorithm. Declaration public bool RefineMesh { get; set; } Property Value Type Description bool"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.RefinementThresholds.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.RefinementThresholds.html",
    "title": "Property RefinementThresholds | BurstTriangulator",
    "keywords": "Property RefinementThresholds RefinementThresholds Declaration public Triangulator.RefinementThresholds RefinementThresholds { get; } Property Value Type Description Triangulator.RefinementThresholds"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.RestoreBoundary.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.RestoreBoundary.html",
    "title": "Property RestoreBoundary | BurstTriangulator",
    "keywords": "Property RestoreBoundary RestoreBoundary If true the mesh boundary is restored using Input constraint edges. Declaration public bool RestoreBoundary { get; set; } Property Value Type Description bool"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.SloanMaxIters.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.SloanMaxIters.html",
    "title": "Property SloanMaxIters | BurstTriangulator",
    "keywords": "Property SloanMaxIters SloanMaxIters Max iteration count during Sloan's algorithm (constraining edges). Modify this only if you know what you are doing. Declaration public int SloanMaxIters { get; set; } Property Value Type Description int"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.ValidateInput.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.ValidateInput.html",
    "title": "Property ValidateInput | BurstTriangulator",
    "keywords": "Property ValidateInput ValidateInput If is set to true, the provided data will be validated before running the triangulation procedure. Input positions, as well as input constraints, have a few restrictions, see README.md for more details. If one of the conditions fails, then triangulation will not be calculated. One could catch this as an error by using Status (native, can be used in jobs). Declaration public bool ValidateInput { get; set; } Property Value Type Description bool"
  },
  "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.TriangulationSettings.html",
    "title": "Class Triangulator.TriangulationSettings | BurstTriangulator",
    "keywords": "Class Triangulator.TriangulationSettings Inheritance object Triangulator.TriangulationSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax [Serializable] public class Triangulator.TriangulationSettings Properties Name Description BatchCount Batch count used in parallel jobs. ConcentricShellsParameter Constant used in concentric shells segment splitting. Modify this only if you know what you are doing! ConstrainEdges If true constrains edges defined in Input using Sloan's algorithm. MaximumArea Specifies the maximum area constraint for triangles in the resulting mesh refinement. Ensures that no triangle in the mesh has an area larger than the specified value. MinimumAngle Specifies the refinement angle constraint for triangles in the resulting mesh. Ensures that no triangle in the mesh has an angle smaller than the specified value. Expressed in radians. MinimumArea Specifies the maximum area constraint for triangles in the resulting mesh refinement. Ensures that no triangle in the mesh has an area larger than the specified value. Preprocessor Preprocessing algorithm for the input data. Default is None. RefineMesh If true refines mesh using Ruppert's algorithm. RefinementThresholds RestoreBoundary If true the mesh boundary is restored using Input constraint edges. SloanMaxIters Max iteration count during Sloan's algorithm (constraining edges). Modify this only if you know what you are doing. ValidateInput If is set to true, the provided data will be validated before running the triangulation procedure. Input positions, as well as input constraints, have a few restrictions, see README.md for more details. If one of the conditions fails, then triangulation will not be calculated. One could catch this as an error by using Status (native, can be used in jobs)."
  },
  "api/andywiecko.BurstTriangulator.Triangulator.html": {
    "href": "api/andywiecko.BurstTriangulator.Triangulator.html",
    "title": "Class Triangulator | BurstTriangulator",
    "keywords": "Class Triangulator Inheritance object Triangulator Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: andywiecko.BurstTriangulator Assembly: .dll Syntax public class Triangulator : IDisposable Constructors Name Description Triangulator(int, Allocator) Triangulator(Allocator) Properties Name Description Input Output Settings Methods Name Description Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Run() Schedule(JobHandle)"
  },
  "api/andywiecko.BurstTriangulator.html": {
    "href": "api/andywiecko.BurstTriangulator.html",
    "title": "Namespace andywiecko.BurstTriangulator | BurstTriangulator",
    "keywords": "Namespace andywiecko.BurstTriangulator Classes Triangulator Triangulator.InputData Triangulator.RefinementThresholds Triangulator.TriangulationSettings Structs Triangulator.OutputData Enums Triangulator.Preprocessor Triangulator.Status"
  },
  "api/andywiecko.html": {
    "href": "api/andywiecko.html",
    "title": "",
    "keywords": ""
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "| BurstTriangulator",
    "keywords": "This is the documentation for the Scripting APIs of this package."
  },
  "changelog/CHANGELOG.html": {
    "href": "changelog/CHANGELOG.html",
    "title": "Change log | BurstTriangulator",
    "keywords": "Change log All notable changes to this project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning. For online version see Github Releases. 2.5.0 – 2024-04-03 Changed Simplified PlantingSeedJob by removing generics and introducing an algorithm based on constraintEdges. This resulted in improved performance. Changed the triangulator to schedule a single job instead of multiple smaller ones. Greatly simplified the preprocessor transformations code. All transformations are now represented by the AffineTransform2D struct, and several jobs have been removed. Deprecated Deprecated the Triangulator.Settings.ConstrainEdges property. To enable constrained edges, pass the corresponding array into input. Deprecated the Triangulator.Settings.BatchCount property. This property is no longer used, setting it has no effect. Fixed Fixed constructing pointToHalfedges during constraint resolution. This resolves GitHub issue #111. 2.4.0 – 2023-12-23 Added Introduce ConcentricShellParameter in TriangulationSettings, serving as a constant for concentric shells segment splitting. Add RefinementThresholds in TriangulationSettings, including .Area and .Angle. Previous corresponding parameters are marked with obsolete. Changed Enhance triangulation refinement for improved quality and performance. Replace the previous algorithm with a new one, similar to Shewchuk's terminator algorithm. The refined mesh now exhibits non-uniform triangle density, with increased density near boundaries and decreased density in the mesh bulk. Update README.md to include a comparison between different refinement settings. Remove the super-triangle approach (resulting in a slight performance boost). Perform refinement after removing holes and boundaries for better refinement quality. Deprecated Mark MinimumArea, MaximumArea, and MinimumAngle as obsolete. Replace these parameters with the more versatile RefinementThresholds. 2.3.0 – 2023-10-25 Changed Improved performance by adapting triangulation with mesh refinement to a half-edges approach. Simplified the refinement job contract. Merged several internal jobs for better efficiency. General project simplification for enhanced maintainability. Removed Eliminated edgeToTriangles and triangleToEdges mappings. Removed the internal Triangle struct. 2.2.0 ⁠– 2023-10-03 Changed Simplified constrained triangulation scheduling jobs pipeline. Adapted constrained triangulation for half-edges approach, which significantly improved performance. The algorithm no longer relies on triangulation mappings, such as edge-to-triangle and triangle-to-edge relationships (or circles). The complexity of the intersection searching algorithm has been reduced from a naive O(n^2) solution to O(n log n). Fixed Resolved Sloan algorithm corner cases. In previous releases, constrained triangulation may get stuck. Constrained triangulation is now more robust. Added Added constrained triangulation benchmark test. The results may be found at README.md. 2.1.0 ⁠– 2023-09-17 Changed Replaced the classic Delaunay algorithm (without refinement/constraints) with an implementation based on half-edges (see delaunator and delaunator-sharp for more details). This change has led to a significant performance boost in unconstrained triangulation. See README.md for more details. Refactored some internal math utilities. 2.0.0 ⁠– 2023-09-09 Added Introduced the Preprocessor enum with the following options: None, COM, and PCA. This enum replaces the previous transformation settings (UseLocalTransformation/UsePCATransformation). Introduced the Status (with values OK, ERR) enum along with corresponding native data. This enum is now utilized for input validation, with functionality extending beyond the Unity editor to encompass validation in builds as well. Added a benchmark test for mesh refinement, which will be used for future performance measurement. Changed Default values for TriangulationSettings. Updated Unity Editor to version 2022.2.1f1. Bumped dependencies: Burst to 1.8.7, Collections to 2.2.0. Removed Removed the following deprecated methods: Schedule(NativeArray<float2>, ...). Removed the following deprecated properties: Positions, Triangles, PositionsDeferred, PositionsDeferred. Removed the internal TriangulatorNativeData as part of a significant refactor to simplify the code structure. Internal implementations were cleaned up, and code structure was simplified. 1.5.0 ⁠– 2023-04-12 Added Added PCA transformation for input positions and holes. Fixed Editor hangs during Sloan algorithm for specific input data (issues #30 and #31). 1.4.0 ⁠– 2022-11-01 Added Added option for transforming input positions (as well as holes) into normalized local space, i.e. [-1, 1] box. Converting points into normalized local space could increase numerical accuracy. Fixed Fix deferred array support in triangulator input. Add missing constraint position range validation. Fix whitespaces in code and README.md. 1.3.0 ⁠– 2022-04-09 Added Restoring input boundaries. The feature allows for restoring a given boundary from triangulation input. It is necessary to provide constraints, as well as enable corresponding options in the triangulation settings, aka RestoreBoundary. Support for holes in the mesh. Upload project's logo generated using the above features. Changed More verbose warnings during input validation. 1.2.0 ⁠– 2022-04-02 Added Add support for the Constraint Delaunay Triangulation with mesh refinement. Changed Performance: Bower-Watson point insertion algorithm has been optimised and is based on the breadth-first search. Refactor: moved a few methods from jobs into TriangulatorNativeData. Refactor: structures have more compact layout. 1.1.0 ⁠– 2022-03-27 Added Add support for Constraint Delaunay Triangulation. Selected edges can be constrained e.g. for restoring the boundary. The feature currently does not support mesh refinement. Basic validation of the input positions as well as input constraint edges. Deprecated Refactor of input/output data buffers, some of them are marked as obsoletes. 1.0.1 ⁠– 2021-11-24 Changed Util function GetCircumcenter has been optimized. It is faster and more stable. Unity packages have been updated (Note: there was API changed in FixedList<T>). 1.0.0 ⁠– 2021-10-26 Added Initial release version"
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "keywords": ""
  },
  "license/LICENSE.html": {
    "href": "license/LICENSE.html",
    "title": "| BurstTriangulator",
    "keywords": "MIT License Copyright (c) 2021 Andrzej Więckowski, Ph.D. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "manual/advanced/input-jobs.html": {
    "href": "manual/advanced/input-jobs.html",
    "title": "Unity.Jobs support | BurstTriangulator",
    "keywords": "Unity.Jobs support Add triangulation to job pipeline This package supports scheduling with Unity.Jobs. You can learn about the job system here. To schedule triangulation, use the Schedule method: dependencies = triangulator.Schedule(dependencies); Catching errors in the job If the triangulation algorithm fails, checking the status and handling it in the job pipeline can be considered. For example: [BurstCompile] private struct Job : IJob { NativeReference<Triangulator.Status>.ReadOnly status; public Job(Triangulator triangulator) { status = triangulator.Output.Status.AsReadOnly(); } public void Execute() { if(status != Triangulator.Status.OK) { return; } ... } } ... var dependencies = default(JobHandle); dependencies = triangulator.Schedule(dependencies); dependencies = new Job(triangulator).Schedule(dependencies); ... Generating input in the job Input can be generated within a job pipeline. You have to use deferred arrays. Here's an example snippet: using var positions = new NativeList<float2>(64, Allocator.Persistent); using var constraints = new NativeList<int>(64, Allocator.Persistent); using var holes = new NativeList<float2>(64, Allocator.Persistent); using var triangulator = new Triangulator(64, Allocator.Persistent) { Input = { Positions = positions.AsDeferredJobArray(), ConstraintEdges = constraints.AsDeferredJobArray(), HoleSeeds = holes.AsDeferredJobArray() } } var dependencies = new JobHandle(); dependencies = new GenerateInputJob(positions, constraints, holes).Schedule(dependencies); dependencies = triangulator.Schedule(dependencies); dependencies.Complete();"
  },
  "manual/advanced/input-validation.html": {
    "href": "manual/advanced/input-validation.html",
    "title": "Input validation | BurstTriangulator",
    "keywords": "Input validation If ValidateInput is set to true, the provided data will be validated before running the triangulation procedure. Input positions, as well as input constraints, have several restrictions: Points count must be greater/equal 3. Points positions cannot be duplicated. Points cannot contain NaNs or infinities. Constraint edges cannot intersect with each other. Constraint edges cannot be duplicated or swapped duplicated. Zero-length constraint edges are forbidden. Constraint edges cannot intersect with points other than the points for which they are defined. If any of these conditions fail, triangulation will not be calculated. You can catch this as an error by using Status (native, can be used in jobs). using var triangulator = new Triangulator(Allocator.Persistent) { Input = { ... }, Settings = { ValidateInput = true }, }; triangulator.Run(); var status = triangulator.Output.Status.Value; Warning Input validation can be expensive. If you are certain of your input, consider disabling this option for additional performance."
  },
  "manual/advanced/preprocessor.html": {
    "href": "manual/advanced/preprocessor.html",
    "title": "Preprocessor | BurstTriangulator",
    "keywords": "Preprocessor Triangulation for non-uniform data can be demanding, and a few algorithm steps may get stuck if the data is not preprocessed properly. It is highly recommended that the user prepares the input data on their own; however, this project provides a few built-in methods. Preprocessor Description None Default, no effect. COM Transforms input into normalized local space, i.e. [-1, 1] box. PCA Transforms input into normalized coordinate systems obtained with principal component analysis. To use one of the following preprocessors, use the corresponding settings: triangulator.Settings.Preprocessor = Triangulator.Preprocessor.COM; PCA transformation This algorithm can help in situations when the Sloan algorithm gets stuck. The transformation can be applied using the following steps: Calculate com: \\(\\mu = \\displaystyle\\frac1n\\sum_{i=1}^n x_i\\). Transform points: \\(x_i \\to x_i -\\mu\\). Calculate covariance matrix: \\(\\text{cov} = \\frac1n\\sum_i x_i x_i^{\\mathsf T}\\). Solve eigenproblem for \\(\\text{cov}\\): \\(\\text{cov}u_i =v_i u_i\\). Transform points using matrix \\(U = [u_i]\\): \\(x_i \\to U^{\\mathsf T} .x_i\\). Calculate vector center \\(c = \\frac12[\\max(x_i) + \\min(x_i)]\\) and vector scale \\(s=2/[\\max(x_i) - \\min(x_i)]\\), where \\(\\min\\), \\(\\max\\), and \"\\(/\\)\" are component wise operators. Transform points: \\(x_i \\to s (x_i-c)\\), assuming component wise multiplication. To summarize, the transformation is given by: \\[ \\boxed{x_i \\to s[U^{\\mathsf T}(x_i - \\mu) - c]} \\] and the inverse transformation: \\[ \\boxed{x_i \\to U(x_i / s + c) + \\mu}. \\] Note The PCA transformation does not preserve the RefinementThresholds.Angle used for refinement. As a result, triangles can be classified as bad in the PCA local space."
  },
  "manual/benchmark.html": {
    "href": "manual/benchmark.html",
    "title": "Benchmark | BurstTriangulator",
    "keywords": "Benchmark The package utilizes the Burst compiler, which generates highly optimized native code using LLVM. Classic Delaunay triangulation Below, you'll find a performance comparison (with Burst enabled) between v2.0.0 and v2.1.0, as well as a comparison with delaunator-sharp for classic Delaunay triangulation (without refinement or constraints). Contrained triangulation Below, you can find a benchmark for constrained triangulation for both v2.1 and v2.2. The test specimen consists of a 100×100 grid with additional #constraints-points distributed in a circle at the center of the grid. In some cases of v2.1, the algorithm gets stuck. Reference timings for non-constrained triangulation are marked with a gray line. In the figure below, you can also see example test cases: red represents resulting triangles, and blue represents constrained edges. Delaunay triangulation with mesh refinement Furthermore, we present a performance comparison (with Burst enabled) between v1.0, v2.0, v2.3, and v2.4 for the refinement task. Note Since v2.4, the triangulation refinement algorithm has been updated, resulting in improved mesh quality."
  },
  "manual/examples/constrained-triangulation.html": {
    "href": "manual/examples/constrained-triangulation.html",
    "title": "Constrained triangulation | BurstTriangulator",
    "keywords": "Constrained triangulation ConstraintEdges Input It is not guaranteed that all edges in the input will be present in the classic Delaunay triangulation result. To ensure specific edges \\(\\{(i, j)\\}\\) are included in the final triangulation, specify the constraints in Input.ConstraintEdges. Provide additional input data as a continuous index array: \\[ [a_0, a_1, b_0, b_1, c_0, c_1, \\dots] \\] This corresponds to constraint edges \\(\\{ (a_0, a_1), (b_0, b_1), (c_0, c_1), \\dots\\}\\). using var constraintEdges = new NativeArray<int>(..., Allocator.Persistent); using var positions = new NativeArray<float2>(..., Allocator.Persistent); using var triangulator = new Triangulator(Allocator.Persistent) { Input = { Positions = positions, ConstraintEdges = constraintEdges, }, }; triangulator.Run(); var triangles = triangulator.Output.Triangles; After providing the corresponding input for the constraints, the result of the constrained triangulation fully covers all specified edges by the user. Constrained triangulation with refinement Constrained triangulation can also be refined in the same manner as non-constrained triangulation by enabling corresponding options in the triangulation settings: triangulator.Settings.RefineMesh = true; After enabling refinement and the constraints, and providing the input, the result of the constrained triangulation fully covers all specified edges by the user, and the mesh is refined according to the given refinement conditions. Warning Without restoring boundaries, the result of mesh refinement, especially in cases with very acute angles, can be of poor quality. Compare this with the result presented in the holes and boundaries example."
  },
  "manual/examples/holes-and-boundaries.html": {
    "href": "manual/examples/holes-and-boundaries.html",
    "title": "Holes and boundaries | BurstTriangulator",
    "keywords": "Holes and boundaries Restoring boundaries The package also provides an option for restoring boundaries. In addition to setting the RestoreBoundary property, one needs to provide edge constraints to restore the boundaries. using var constraintEdges = new NativeArray<int>(..., Allocator.Persistent); using var positions = new NativeArray<float2>(..., Allocator.Persistent); using var triangulator = new Triangulator(Allocator.Persistent) { Input = { Positions = positions, ConstraintEdges = constraintEdges, }, Settings = { RestoreBoundary = true, } }; triangulator.Run(); var triangles = triangulator.Output.Triangles; Holes supports The package also provides an option for creating holes. In addition to setting the Input.ConstraintEdges, a user needs to provide positions of the holes in the same space as the Input.Positions. Enabling the RestoreBoundary option is not mandatory; holes could be introduced independently of preserving the boundaries. using var constraintEdges = new NativeArray<int>(..., Allocator.Persistent); using var holes = new NativeArray<float2>(..., Allocator.Persistent); using var positions = new NativeArray<float2>(..., Allocator.Persistent); using var triangulator = new Triangulator(Allocator.Persistent) { Input = { Positions = positions, ConstraintEdges = constraintEdges, HoleSeeds = holes, }, Settings = { RestoreBoundary = true, // optional can be set independently } }; triangulator.Run(); var triangles = triangulator.Output.Triangles;"
  },
  "manual/examples/index.html": {
    "href": "manual/examples/index.html",
    "title": "Example usage | BurstTriangulator",
    "keywords": "Example usage Below is an example usage of the Triangulator with an input set consisting of four points that form the unit square: using var positions = new NativeArray<float2>(new float2[] { new(0, 0), new(1, 0), new(1, 1), new(0, 1), }, Allocator.Persistent); using var triangulator = new Triangulator(capacity: 1024, Allocator.Persistent) { Input = { Positions = positions } }; triangulator.Run(); var triangles = triangulator.Output.Triangles; Tip The triangulator.Run() method runs on the main thread. If you want to call this within a jobs pipeline, schedule a job using triangulator.Schedule(dependencies). Click here to learn how to use triangulation within a jobs pipeline. If triangulation fails for some reason, you can catch the information using Status status = triangulator.Output.Status.Value; if (status == Triangulator.Status.ERR) // ERROR! { return; } The result of the triangulation procedure will depend on the selected settings. There are a few settings for triangulation, which are briefly described in the API documentation. Follow the articles in the manual to learn more about settings. In other examples, the following cool guitar was used as an input test case:"
  },
  "manual/examples/mesh-refinement.html": {
    "href": "manual/examples/mesh-refinement.html",
    "title": "Triangulation with refinement | BurstTriangulator",
    "keywords": "Triangulation with refinement To proceed with triangulation using mesh refinement, set RefineMesh to true and specify the required RefinementThresholds: using var inputPositions = new NativeArray<float2>(..., Allocator.Persistent); using var triangulator = new Triangulator(Allocator.Persistent) { Input = { Positions = inputPositions }, Settings = { RefineMesh = true, RefinementThresholds = { Area = 1f, Angle = math.radians(20f) }, } }; triangulator.Run(); var triangles = triangulator.Output.Triangles; var positions = triangulator.Output.Positions; The refinement process is controlled by two threshold parameters: Area: denoted as \\(C_\\triangle\\) Angle: denoted as \\(C_\\theta\\) These parameters allow fine-tuning of the refinement results based on specific criteria. Below, you can observe a set of results obtained by applying the refinement process to input data from Lake Superior (open the image in a new tab to see the details). Note Refinement is available for both constrained and non-constrained triangulation."
  },
  "manual/examples/triangulation.html": {
    "href": "manual/examples/triangulation.html",
    "title": "Delaunay triangulation | BurstTriangulator",
    "keywords": "Delaunay triangulation To perform a classic, i.e., non-constrained without refinement, Delaunay triangulation, use the following: using var positions = new NativeArray<float2>(..., Allocator.Persistent); using var triangulator = new Triangulator(Allocator.Persistent) { Input = { Positions = positions } }; triangulator.Run(); var triangles = triangulator.Output.Triangles; Tip Classic triangulation will produce convex hull of the given input. To learn how to restore the boundary click here."
  },
  "manual/getting-started.html": {
    "href": "manual/getting-started.html",
    "title": "Getting started | BurstTriangulator",
    "keywords": "Getting started Install the package using one of the following methods. Using OpenUPM is recommended. OpenUPM git Manual Copy Follow the tutorial at OpenUPM docs. Alternatively, you can set up manifest.json manually. Add or modify scoped registries in the manifest: \"scopedRegistries\": [ { \"name\": \"OpenUPM\", \"url\": \"https://package.openupm.com/\", \"scopes\": [ \"com.andywiecko\" ] } ] Then, in the dependencies section, provide the desired version of the package: \"dependencies\": { \"com.andywiecko.burst.triangulator\": \"2.5.0\", ... Refer to the Unity docs for more details. Use the package manager via git install: https://github.com/andywiecko/BurstTriangulator.git Alternatively, you can edit manifest.json manually: \"dependencies\": { \"com.andywiecko.burst.triangulator\": \"https://github.com/andywiecko/BurstTriangulator.git\", ... Note By default this method will install the latest commit from the main branch of the project repo. You can specify a tag or commit by providing an additional hash, e.g. to install package v2.4.0 use: https://github.com/andywiecko/BurstTriangulator.git#v2.4.0; to install package at commit f206441912d8b3fda00fe7438db2a1eec4da5a64 use: https://github.com/andywiecko/BurstTriangulator.git#f206441912d8b3fda00fe7438db2a1eec4da5a64. Clone or download this repository and then select package.json using Package Manager (Window/Package Manager). Since the package is single-file only, one can place the file Runtime/Triangulator.cs somewhere in the project to use it independently. Just remember to install the proper package dependencies. Dependencies BurstTriangulator has the following dependencies: Unity.Burst@1.8.7 Unity.Collections@2.2.0"
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "| BurstTriangulator",
    "keywords": "A single-file package which provides Delaunay triangulation of the given set of points with constraints and mesh refinement. To showcase the functionality of our package, we provide an illustrative example featuring the triangulation of Lake Superior using different refinement parameters. The top-left image displays the initial result without any refinement applied."
  },
  "manual/introduction.html": {
    "href": "manual/introduction.html",
    "title": "Introduction | BurstTriangulator",
    "keywords": "Introduction Delaunay triangulation Triangulation is a process that converts a set of points into a triangles mesh. This package implements Delaunay triangulation, ensuring that every triangle's circumcircle contains no points from within the mesh. It's important to note that the result will be the convex hull of the input points. Given a set of positions \\(\\{p_i\\}\\) as input, the output is the triangulation \\(\\mathcal{T}\\). Constrained triangulation In addition to basic triangulation, users may want to enforce certain edges in the final mesh. This can be achieved by providing additional input specifying edge vertices. However, it's worth noting that the resulting triangulation may not maintain the Delaunay property. The input for constrained triangulation includes a set of positions \\(\\{p_i\\}\\) and constraint edges \\(\\{(i, j)\\}\\), with the output being the triangulation \\(\\mathcal{T}\\). Mesh refinement In computational simulations, accurately representing long, thin triangles is often challenging. To address this issue, additional points can be strategically inserted into the triangulation to eliminate these problematic elements. Since simulation time is typically proportional to the number of triangles, it's crucial to strike a balance: minimizing the number of triangles while maintaining sufficient detail for accurate results. In this process, denoted as mesh refinement, the input triangulation \\(\\mathcal{T}\\) is transformed into \\(\\mathcal{T'}\\) by inserting additional points to split edges or triangles. Restore boundary As previously mentioned, Delaunay triangulation produces the convex hull of points. To support non-convex shapes, edge constraints are introduced, and triangles not included in the boundary of the constraints are removed. Given a set of positions \\(\\{p_i\\}\\) and constraints \\(\\{(i, j)\\}\\) as input, the output is the triangulation \\(\\mathcal{T}\\), ensuring that the resulting mesh adheres to the specified boundary constraints. Holes Triangulation can be extended to support meshes with holes. Additional input data, such as hole seeds \\(\\{h_i\\}\\), is required for this purpose. Although automation of this process is currently not implemented, it is planned for future development. Hole seeds act as starting points for a removal process resembling the spread of a virus. Starting from the triangle containing \\(h_i\\), neighboring triangles are successively removed until the search reaches the constraint edge. In this process, constraint edges act as barriers, preventing further propagation of the removal. Implementation In this package implemented classic Delaunay triangulation is based on delaunator and delaunator-sharp. Refinement algorithm is based on Ruppert's algorithm1 with Bowyer–Watson algorithm2 3 point insertion. Refinement procedure is inspired by Shewchuk's terminator algorithm4. The package provides also constrained triangulation (with mesh refinement) which is based on Sloan's algorithm5. Throughout these algorithms, the package utilizes the half-edges data structure. For further exploration, we recommend referring to the following article. Currently, the sequence of actions in the implementation follows: \\[ \\begin{array}{c} \\boxed{\\text{Preprocessor}}\\\\ \\Downarrow\\\\ \\boxed{\\text{Delaunay triangulation}}\\\\ \\Downarrow\\\\ \\boxed{\\text{Edge constraints}}\\\\ \\Downarrow\\\\ \\boxed{\\text{Planting holes}}\\\\ \\Downarrow\\\\ \\boxed{\\text{Refine mesh}}\\\\ \\Downarrow\\\\ \\boxed{\\text{Postprocessor}}\\\\ \\end{array} \\] Bibliography J. Ruppert. \"A Delaunay Refinement Algorithm for Quality 2-Dimensional Mesh Generation\". J. Algorithms 18(3):548-585 (1995).↩ A. Bowyer. \"Computing Dirichlet tessellations\". Comput. J. 24 (2): 162–166 (1981).↩ D. F. Watson. \"Computing the n-dimensional Delaunay tessellation with application to Voronoi polytopes\". Comput. J. 24 (2): 167–172 (1981).↩ J. R. Shewchuk. \"Delaunay refinement algorithms for triangular mesh generation.\" Comput. Geom. 22.1-3 (2002).↩ S. W. Sloan. \"A fast algorithm for generating constrained Delaunay triangulations.\" Comput. Struct. 47.3:441-450 (1993).↩"
  },
  "manual/known-issues.html": {
    "href": "manual/known-issues.html",
    "title": "Known Issues | BurstTriangulator",
    "keywords": "Known Issues #103: Leak Detected Warning in the Console In the Unity Editor, you may encounter the following log message: Leak Detected : Persistent allocates 257 individual allocations. To find out more please enable 'Jobs/LeakDetection/Full StackTraces' and reproduce the leak again. Not to worry, this issue is likely related to an internal bug in the Unity.Collections or Unity.Burst package (related to NativeQueue<> allocation). #105, #106: Incorrect triangulations for complicated input Due to floating-point precision, triangulation may fail for some input. This is often related to single-point precision. Changing coordinates from float2 to double2 solves the issue. This will be addressed in the upcoming release. If you want to try it now, there is an experimental branch available here."
  }
}